<html>
<head>
  <title>Display NG Mesh</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js"></script>
  <script src="js/TrackballControls.js"></script>
  <script src="../dist/ngmesher.js"></script>
  <style>

  body {

    color: #000;
    font-family:Monospace;
    font-size:13px;
    text-align:center;
    background-color: #ADD;
    margin: 0px;
    overflow: hidden;
  }

  #info {
    z-index: 10;
    text-align: left;
    margin: 10px;
    position: fixed;
    top: 0;
    left: 0;
  }

  #info code {
    background-color: #8BB;
    line-height: 1.5;
  }

  #container {
    z-index: 1;
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
  }

  </style>

</head>
<body>

  <div id="info">
    <input type="file" id="fileInput">
  </div>

  <div id="container"></div>



  <script>
  window.onload = function() {

    var fileInput = document.getElementById('fileInput');


    // event listener of the file dialog, it then triggers the file decoding
    fileInput.addEventListener('change', function(e) {
      var files = e.target.files;
      var reader = new FileReader();

      if( !files.length ){
        return;
      }

      reader.onloadend = function(event) {
        var buffer = event.target.result;
        console.log(buffer);

        let t0 = performance.now()
        let meshData = ngmesher.decode(buffer)
        let t1 = performance.now()
        build3DMeshFromNgMeshData(meshData);
        console.log("Parsed in " + (t1-t0) + " ms.");

      }

      reader.readAsArrayBuffer( files[0] );
  	});



    //*********************************

    var container;
    var sphereContainer = new THREE.Object3D();
    var camera, scene, renderer;
    var objectContainer = new THREE.Object3D();
    var controls = null;

    init();
    animate();


    function init() {
      container = document.getElementById( 'container' );
      camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 100000 );
      camera.position.z = 500;


      controls = new THREE.TrackballControls( camera );
      controls.rotateSpeed = 3.0;
      controls.zoomSpeed = 1.5;
      controls.panSpeed = 0.8;
      controls.noZoom = false;
      controls.noPan = false;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;

      scene = new THREE.Scene();
      //scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );
      scene.add( new THREE.AmbientLight( 0x444444 ) );
      scene.add(camera)

      var light1 = new THREE.DirectionalLight( 0xffffff, 1 );
      light1.position.set( 0, 0, 0 );
      camera.add( light1 );

      //var light2 = new THREE.DirectionalLight( 0xffffff, 1.5 );
      //light2.position.set( 0, -1, 0 );
      //camera.add( light2 );

      scene.add( objectContainer );

      renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
      renderer.setClearColor( 0xffffff, 0 );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.gammaInput = true;
      renderer.gammaOutput = true;

      container.appendChild( renderer.domElement );
      window.addEventListener( 'resize', onWindowResize, false );
    }


    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
      controls.handleResize();
    }


    function animate() {
      requestAnimationFrame( animate );
      controls.update();
      render();
    }


    function render() {
      renderer.render( scene, camera );
    }



    // build a Threejs Mesh from a Pixpipe Mesh3D
    function build3DMeshFromNgMeshData( meshData ){


      var positions = meshData.vertices;
      var indices = meshData.triangles;

      var geometry = new THREE.BufferGeometry();
      geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
      geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
      geometry.computeBoundingSphere();
      geometry.computeVertexNormals()

      var material = new THREE.MeshPhongMaterial( {
        specular: 0xffffff,
        shininess: 250,
        side: THREE.DoubleSide,
        color:  Math.floor(Math.random() * 0xFFFFFF),
        transparent: true,
        opacity: 0.8,
      } );

      var mesh = new THREE.Mesh( geometry, material );
      objectContainer.add( mesh );

      console.log(geometry);
      camera.position.x = geometry.boundingSphere.center.x + geometry.boundingSphere.radius
      camera.position.y = geometry.boundingSphere.center.y
      camera.position.z = geometry.boundingSphere.center.z
      camera.lookAt(geometry.boundingSphere.center)
      controls.target.copy(geometry.boundingSphere.center)

      var geometryS = new THREE.SphereBufferGeometry( 5, 32, 32 );
      var materialS = new THREE.MeshBasicMaterial( {color: 0xffff00} );
      var sphere = new THREE.Mesh( geometry, material );

      sphere.position.x = geometry.boundingSphere.center.x - geometry.boundingSphere.radius
      sphere.position.y = geometry.boundingSphere.center.y
      sphere.position.z = geometry.boundingSphere.center.z

      objectContainer.add( sphere );
      render()
    }

  }
  </script>

</body>
</html>
